Spring boot:  

Spring Boot is a Java framework that makes it easier to create and run Java applications. It simplifies the configuration and setup process, allowing developers to focus more on writing code for their applications. 

It is a combination of Spring Framework and Embedded Servers. 

Auto Configuration ‚Äì Spring Boot automatically configures your application based on the dependencies you add. 

‚öôÔ∏è Starter Dependencies ‚Äì Predefined starter packages like spring-boot-starter-web, starter-data-jpa to quickly set up common functionality. 

üß™ Embedded Servers ‚Äì Comes with built-in Tomcat, Jetty, etc., so no need to deploy WAR files separately

Very Important : 
 
First client makes an HTTP request ( GET, POST, PUT, DELETE ) to the browser. 

After that the request will go to the controller, where all the requests will be mapped and handled. 

After this in Service layer, all the business logic will be performed. It performs the business logic on the data that is mapped to JPA (Java Persistence API) using model classes. 
 
In the repository layer, all the CRUD operations are being done for the REST APIs. 

What are Starter Dependencies? 

Starter dependencies are predefined packages provided by Spring Boot that bundle together commonly used libraries and configurations for a specific purpose ‚Äî so you don‚Äôt have to add each dependency manually. 

Both are configuration files used in Spring Boot to define settings like database credentials, server port, logging, etc. 
 The only difference is format 

application.properties 

Format: Key = Value 

Simple, flat structure 

‚úÖ Easy for small configs 

‚ùå Becomes messy for nested structuresc 

 

application.yml (YAML) 

Format: Indented (key-value with nesting) 

‚úÖ Cleaner for complex or nested config 

‚úÖ More readable for hierarchical data 

‚ùå Sensitive to indentation (spacing must be correct) 

 

server.port=8081 

spring.datasource.url=jdbc:mysql://localhost:3306/mydb 

spring.datasource.username=root 

spring.datasource.password=pass 

 

server: 

  port: 8081 

  

spring: 

  datasource: 

    url: jdbc:mysql://localhost:3306/mydb 

    username: root 

    password: pass 

Here, spring is a parent key. 

datasource is inside spring (child), so it‚Äôs indented. 

url, username, password are indented again under datasource 

 

 

 

 

A Spring Bean is simply an object managed by the Spring container. Its lifecycle involves various stages:  

 

 

1.Instantiation ‚Äì Spring creates an instance of the bean.  

Spring creates an instance of a bean using Java's reflection mechanism ‚Äî meaning it calls the constructor of your class automatically when starting up the application. 

Then stores it in the Application Context (container). 

In Spring, the Application Context is the core container that holds all the beans in the application. Think of it like a big storage unit where Spring keeps track of every bean it manages, such as services, repositories, controllers, etc. 

Managing beans (i.e., storing and providing them when needed). 

Handling the lifecycle of beans (i.e., creating, initializing, destroying). 

Managing dependencies (injecting other beans into beans). 

It is typically stored in a map-like structure (called bean factory in earlier versions). The key could be the class name or the bean name, and the value is the actual instance of the bean. 

When other parts of the application (like controllers or services) need a specific bean, Spring retrieves it from the ApplicationContext. This is done through dependency injection or direct lookup using methods like getBean(). 

Any time this bean is needed elsewhere, Spring gives the same instance (singleton by default). 

 
2.Populate Properties ‚Äì Dependencies are injected (via constructor, setter, or field). 3.BeanNameAware (optional) ‚Äì Bean is made aware of its name in the Spring container. 
 
Spring creates the bean: Spring creates an object (bean) and places it inside the container. 

BeanNameAware interface: If the class implementing that bean has BeanNameAware, it gets the opportunity to know its name inside the container. 

public void setBeanName(String name) {  

this.beanName = name; // Spring gives the bean its name here  

} 

You can later use the getBeanName() method to get the name of the bean whenever needed. 

 
 4.BeanFactoryAware / ApplicationContextAware (optional) ‚Äì Bean gets access to Spring context.  

It provides a mechanism for beans to be aware of and interact with the Spring container, allowing for flexible and dynamic bean retrieval and management. This is especially useful when you don't know the exact beans you need at compile time but need to retrieve them dynamically at runtime. 

 

5.Pre-initialization (@PostConstruct) ‚Äì Initialization logic runs after dependencies are set.  

6.AfterPropertiesSet() ‚Äì If bean implements InitializingBean, this is called. 

When your bean implements the InitializingBean interface, Spring will automatically call the afterPropertiesSet() method after all the properties (dependencies) are injected 
 
Note: Spring is setting up the furniture (dependencies). 

Once everything is arranged, you get a call: 
 "You can now decorate or organize things as per your need! 

7.Custom init-method ‚Äì If specified in config.  

In simple terms: If you want to perform some initialization logic that isn't handled by @PostConstruct or InitializingBean, you can define your own method. 
 
8.Ready to use ‚Äì Bean is fully initialized.  

9.Destroy ‚Äì On shutdown, Spring calls: @PreDestroy destroy() (if DisposableBean implemented) Custom destroy-method (if configured) 
@PreDestroy: A special annotation that runs cleanup logic before the bean is destroyed. 

destroy(): If the bean implements the DisposableBean interface, the destroy() method is called automatically. 

Spring Boot dependency management: 
Spring Boot dependency management is a feature that helps you manage the libraries and dependencies your Spring Boot application needs to run. 

Automatic Version Management: Spring Boot provides predefined versions of libraries. This means you don‚Äôt need to specify the version for most dependencies. Spring  

Starter Dependencies: Spring Boot includes "starter" dependencies, which are sets of commonly used libraries grouped together for specific tasks. 
 For example: 

spring-boot-starter-web includes libraries for building web applications. 

spring-boot-starter-data-jpa includes libraries for working with JPA (Java Persistence API). 

Transitive Dependencies: If you include a library that has other libraries it depends on, Spring Boot automatically includes those as well. 

 
What is the default port of Tomcat in spring boot? 

The default port of the embedded Tomcat server in Spring Boot is 8080. We can change the default port by setting the server. port property in your application‚Äôs application. properties file. 

 

In Spring Boot can you disable the web server? 
 
Yes, in Spring Boot, you can disable the default web server (which is typically Tomcat). This means that your application won't automatically start an embedded web server, which is useful if you're building a non-web application 

By default, Spring Boot includes an embedded web server (Tomcat, Jetty, or Undertow) when you add spring-boot-starter-web as a dependency. This web server starts automatically when your application runs, serving web requests. 

in application.properties: 

spring.main.web-application-type=none  

application.properties: 

server.port=-1 

in java code 

app.setWebApplicationType(WebApplicationType.NONE); 

 

 
My backend journey  

 
The REST API (Representational State Transfer) is an interface is a part refers to the set of HTTP endpoints defined using annotations like @RestController, @RequestMapping, @GetMapping, @PostMapping, etc. To access and manipulate resources (like data from a database). 

@RestController 

This tells Spring that this class handles RESTful HTTP requests 

HTTP Method	Annotation	Purpose	REST API URL 

POST	@PostMapping	Create a student	POST /api/students 

GET	@GetMapping	Get all students	GET /api/students 

GET	@GetMapping	Get one by ID	GET /api/students/{id} 

PUT	@PutMapping	Update a student	PUT /api/students/{id} 

DELETE	@DeleteMapping	Delete a student	DELETE /api/students/{id} 

 

 

 

 

Annotations we use to building a REST API 
 
 

Rest Controller 

We use it on class 

Rest controller will let the spring know this class has a relationship with the rest Api method. 

Rest controller is a combination of controller and response body so it will automatically convert Java objects to JSON.  
 

@RequestMapping 

We use it on class 

Rest controller will let the spring know this class has a relationship with the rest Api method. 

Rest controller is a combination of controller and response body so it will automatically convert Java objects to JSON.  


Used on both class and methods 

Request Mapping is used to map HTTP requests to handler methods in your controller. 

 

Note: 
On Class Level ‚Äì Base URL 

@RequestMapping("/api/students") 

On Method ‚Äì Specific Endpoint 

@RequestMapping (value = "/greet", method = RequestMethod.GET) 

 

@GetMapping 
Handles HTTP GET requests.(not modifying anything). 
Used to retrieve resources. 

Example:  

return studentService.getAllStudents() 

@postMapping 

 

Note : 
üîπ Body: JSON with new student details 

üîπ Spring Boot does: 

Reads the JSON from the request 

Converts it into a student object 

Saves it to the database 

 

Used to create a new resource (like saving to a database). 

Example : 
Step 1 : 
@PostMapping("/students") 

public Student createStudent(@RequestBody Student student) { 

    return studentService.saveStudent(student); 

} 
Step 2 : 
{ 

  "name": "Nivedha", 

  "email": "nivedha@example.com", 

  "age": 22 

} 

Step 3: 

POST /students ‚Üí Adds this student to the DB

@PutMapping 

Body: Updated JSON (entire object) 

Spring Boot does: 

Gets the student ID from the path 

Parses the JSON body 

Updates the existing record in DB 

 

Used to update an existing resource entirely. 

Step 1: 
@PutMapping("/students/{id}") 

public Student updateStudent(@PathVariable Long id, @RequestBody Student student) { 

    return studentService.updateStudent(id, student); 

} 

 

@DeleteMapping 
 
Used to delete a resource by ID or key. 

@DeleteMapping("/students/{id}") 

public void deleteStudent(@PathVariable Long id) { 

    studentService.deleteStudent(id); 

} 

 

@PathVariable 

@PathVariable helps you capture that value from the URL. 

It tells Spring: 

"Hey! Take the value from the URL path and map it to this method parameter." 

Note:  

If the client sends a request like: 
 GET /students/5 

Then @PathVariable will extract 5 and assign it to the id parameter. 

Otherwise, 
You‚Äôd have to send the ID as a query parameter: 
GET /students?id=101 

Example :  

  @DeleteMapping("/{id}") 
public String deleteUser(@PathVariable Long id) { 
boolean isDeleted = userService.deleteUserById(id); 
if (isDeleted) { 

            return "User with ID " + id + " has been deleted."; 

        } else { 

            return "User with ID " + id + " not found."; 

        } 

    } 
THE SERVICE: 
 

public boolean deleteUserById(Long id) { 

            if (id == 101) { 

            return true;          } 

        return false;      } 

Request Param 
 
what is what? 
Note: @PathVariable: 
 The value is required for identifying the resource. If missing, the API will fail (usually with a 404 error). 

@RequestParam: 
 The value is often optional and can have default values if not provided. 


Actual summary: 
 
@PathVariable: Used for required parts of the URL path that usually represent unique identifiers (e.g., user ID, product ID). This is common in RESTful design. 

@RequestParam: Used for optional query parameters in the URL, often for filters, sorting, or pagination. It is flexible and can have default values. 

 

@RequestParam is used to extract query parameters from the URL. 

It is typically used to handle parameters in the URL that follow the ? symbol in a request. 

 
GET /students?id=101&name=John 

Here, id and name are query parameters. 

 

You can also provide default values for query parameters in case they are missing in the URL. 
 
@GetMapping("/students") 
public String getStudent(@RequestParam(name = "id", defaultValue = "0") Long id; 
 

Example:  
   @GetMapping("/details") 

    public String getStudentDetails(@RequestParam Long id, @RequestParam String name) { 

        return "Student ID: " + id + ", Name: " + name; 

    } 

 

@RequestBody ‚Äî Input from Client to Server 

üßæ Used to take data from the client (like JSON) and convert it into a Java object 

Example: 
 
public Student addStudent(@RequestBody Student student) { 

    // The JSON will be converted into a Student object 

    return student; 

} 

@ResponseBody 
 
Used to take a Java object from your method and convert it into JSON/XML to send back to the client 

 

@ResponseBody is used in Spring to indicate that the return value of a method should be written directly to the HTTP response body, rather than being resolved to a view (like JSP or HTML). It is often used in RESTful web services to send the response data as JSON, XML, or any other content type directly 

@ResponseBody 

    public String sayHello() { 

        return "Hello from Spring Boot!"; 

    } 

} 

üìå In this case, @ResponseBody tells Spring: 


"Don't look for a view like hello.jsp ‚Äî just return this string directly to the browser or client." 

 

Note: 
In Spring Boot, @RestController is a specialized version of @Controller. It combines @Controller and @ResponseBody, so you don‚Äôt need to write @ResponseBody on each method. 

@RestController(class level)= @Controller + @ResponseBody(method level) 
 So every method behaves as if it has @ResponseBody by default. 

@Autowired 
Only Spring-managed Beans can be injected using @Autowired. 

@Autowired is used for Dependency Injection (DI) in Spring. 

It tells Spring: 
"Hey Spring, please automatically inject (or wire) this dependency for me! 

Because in big applications, we don‚Äôt want to manually create objects using new. Spring handles object creation and wiring automatically to promote loose coupling and easy testing. 

 

Location 

Example 

Field (most common) 

‚úÖ 

Constructor 

‚úÖ (Recommended for final fields) 

Cleaner, better for unit testing (because you can pass mock objects in the constructor). 

Setter method 

‚úÖ Used when the dependency is optional or can be changed after creation. 

 

Example code 
service file 
 
@Service 

public class StudentService { 

    public String getStudentName(Long id) { 

        return "Nivedha"; // Dummy data for now 

    } 

} 

Controller file: 
 
@RestController 

@RequestMapping("/students") 

public class StudentController { 

  

    @Autowired 

    private StudentService studentService;  // üîÅ Injected automatically by Spring 

  

    @GetMapping("/{id}") 

    public String getStudent(@PathVariable Long id) { 

        return studentService.getStudentName(id); 

    } 

} 

No need to use new StudentService() ‚Äî Spring handles that for you. 

@Service annotation 
 
Registers the class as a Spring Bean. 
 
 

Used in which layer? 

Service Layer (between Controller & Repository) 

 

@Service is a Spring stereotype annotation used to mark a class as a service layer component. 

In simple words: 

It tells Spring, "Hey! This class contains business logic, and you should manage it as a Spring Bean." 

Allows it to be injected into other classes using @Autowired. 

What is spring bean? 
 
Component Scan mechanism that looks for these annotations 

A Spring Bean is simply an object that is managed by the Spring Container (ApplicationContext). 

When you mark a class with @Service, @Component, or @Repository, Spring automatically creates an instance of that class and manages it ‚Äî this instance is called a bean. 

Code : 
 
@Service  // <-- Spring sees this and creates a Bean 

public class StudentService { 

    public String getStudentName(Long id) { 

        return "Nivedha"; 

    } 

} 

 

@RestController 

public class StudentController { 

  

    @Autowired  // <-- Spring injects the Bean here 

    private StudentService studentService; 

  

    @GetMapping("/students/{id}") 

    public String getName(@PathVariable Long id) { 

        return studentService.getStudentName(id); 

    } 

} 

 
Note : Checks: "Do I have a bean of type StudentService?" 

‚úÖ If yes ‚Üí injects it automatically. 

‚ùå If not ‚Üí throws an error: "No qualifying bean of type found." 

 

@component 

What is @Component?  
Component	is a Generic component 

@Component is a generic stereotype annotation in Spring used to mark a class as a Spring-managed Bean. 

Once a class is annotated with @Component, Spring will detect it during component scanning and automatically register it as a bean. 

It's like the parent of other annotations like @Service, @Repository, and @Controller. 

 

@Repository 

@Repository is a Spring stereotype annotation that marks a class as a Data Access Object (DAO) ‚Äî responsible for interacting with a database. 
 
Tells Spring: "This class handles data storage, retrieval, update, and deletion 
 

public interface StudentRepository extends JpaRepository<Student, Long> { } 
whats the purpose of JpaRepository? 

Key Features of JpaRepository 
CRUD Methods: You get methods like save(), findAll(), findById(), delete(), 

@EnableAutoConfiguration  
 
very important : 
@SpringBootApplication 

Which is a shortcut for: 

 
@Configuration              Marks the class as a source of bean definitions 

@EnableAutoConfiguration    Enables Spring Boot‚Äôs auto-configuration feature 

@ComponentScan              Scans the current package and sub-packages for Spring components 

 

It is a Spring Boot annotation that tells Spring Boot to automatically configure your application based on the dependencies you‚Äôve added to your project. 

 

If you add spring-boot-starter-web to your project: 

Spring Boot sees that and: 

Sets up an embedded Tomcat server. 

Enables Spring MVC. 

Sets up default error handling. 

All of this happens because of @EnableAutoConfiguration. 

so you don‚Äôt have to write a lot of boilerplate code 

@AutoConfiguration 

Used by library creators (not app developers). 

Defines a new auto-configuration class that Spring Boot will include only if certain conditions are met (like if a specific dependency is present). 

Introduced in Spring Boot 3.x as a cleaner way to create custom auto-configs. 

@GetMapping("/login") 

public String login(@RequestParam(value = "error", required = false) String error, 

@RequestParam(value = "logout", required = false) String logout, 

Model model) { 

if (error != null) { 

model.addAttribute("error", "Invalid username or password."); 

} 

if (logout != null) { 

model.addAttribute("message", "You have been logged out successfully."); 

} 

return "login"; 

} 

 
Redirect: 
@PostMapping("/toNetBanking") 

public String redirectToNetBanking() { 

return "redirect:/netbanking"; // Redirect to the NetBanking page 

} 
@PostMapping("/login") 

public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequestDto authenticationRequest) throws Exception { 

 

Authentication authentication= authenticationManager.authenticate( 

new UsernamePasswordAuthenticationToken(authenticationRequest.getUsername(), authenticationRequest.getPassword()) 

); 

SecurityContextHolder.getContext().setAuthentication(authentication); 

final UserDetails userDetails = (UserDetails)authentication.getPrincipal(); 

final String token = jwtTokenUtil.generateToken(userDetails); 

System.out.println(userDetails.getAuthorities().toString()); 

return ResponseEntity.ok(new JwtResponseDto(token).getToken()); 

} 
 
Need to know: 
By default: 

Spring only scans inside the package where your main class lives and its sub-packages. 

So, if your main class is: 

@SpringBootApplication 
public class MyApp { 
    public static void main(String[] args) { 
        SpringApplication.run(MyApp.class, args); 
    } 
} 
 

And it lives in: 

com.example.myapp 
 

Then Spring will scan: 

com.example.myapp 
com.example.myapp.controllers 
com.example.myapp.services 
com.example.myapp.repositories 

 
What happens if Spring can't find a matching bean? 

You‚Äôll get an error like: No qualifying bean of type 'Xyz' available 
 

To avoid this, you can make it optional: 
@Autowired(required = false) 
private MyBean optionalBean; 

@entity 

@Entity: Marks the class as a JPA entity, meaning this class will be mapped to a table in the database. 

Spring Boot (via Hibernate) will create a table for this class (if it doesn't exist). 

Each instance of the class becomes a row in the table. 

 

@Table 

@Table(name = "students") 

Specifies the name of the database table this entity maps to. 

If you don‚Äôt specify this, Hibernate will name the table same as the class (Student becomes student). 

 

@id 

Marks the field as the Primary Key of the table. 

@GeneratedValue 

Automatically generates the value for the primary key (usually auto-increment). 
 
Picture 

@Configuration 

@Configuration is a Spring annotation used to define a class that contains bean definitions ‚Äî meaning, this class tells Spring how to create and manage certain objects 

 

A class marked with @Configuration is a Java version of an XML configuration file (like applicationContext.xml). 

@Bean methods are placed inside @Configuration-annotated classes. 

<bean id="myService" class="com.example.MyService"/> 

OR) 
@Bean  

public MyService myService() {  

return new MyService();  

} 

 

It scans the class with @Configuration 

It sees all @Bean methods 

It runs them only once 

It stores the returned objects in the Spring Container 

You can then inject those beans anywhere using @Autowired 

Only one instance created 

Spring ensures beans are singleton by defaul 

 

@CrossOrigin is a Spring annotation that enables CORS (Cross-Origin Resource Sharing). 
 
 
 

Can be applied 

On methods, controllers, or globally via config 

 

When your frontend (like React running on http://localhost:3000) tries to make a request to your backend API (like Spring Boot on http://localhost:8080), the browser blocks it unless CORS is enabled. 

That's where @CrossOrigin comes in ‚Äî it tells the browser: 

"Yes, I allow requests from another domain!" 

If you want to allow CORS globally for all controllers:  
@Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**") .allowedOrigins("http://localhost:3000") .allowedMethods("GET", "POST", "PUT", "DELETE"); } 

Access to fetch at 'http://localhost:8080/api/students'  

from origin 'http://localhost:3000' has been blocked by CORS policy 

 

 

@Valid is used to trigger validation on an object 

@RequestBody 

Tells Spring: "This data is coming from the body of the HTTP request." 

Spring automatically converts the JSON body into a student object 

From  
{ 

  "name": "Nivedha", 

  "age": 17, 

  "email": "nivedha@email" 

} 

To  
Student student = new Student("Nivedha", 17, "nivedha@email"); 
 
 
@Valid 

Triggers validation on the Student object right after it‚Äôs created. 

Spring checks the fields like @NotBlank, @Email, @Min(18), etc. 

If any validation rule fails 
----->>> Spring will automatically return a 400 Bad Request with error messages like: 

For customization : 
{ 
  "errors": [ 
    "Name is required", 
    "Email should be valid" 
  ] 
} 
 
Picture 

You can also customize the response using @ExceptionHandler 

 

@ExceptionHandler 

@ExceptionHandler: is used to catch exceptions thrown by your controller methods and customize the response. 

@ExceptionHandler(RuntimeException.class)  

public ResponseEntity<String> handleRuntimeException(RuntimeException ex) {  

return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)  

.body("Error: " + ex.getMessage());  

} 

@ControllerAdvice 

The next natural step is @ControllerAdvice. 
 It makes your exception handling global instead of repeating it in every controller. 

 
 
To know: 
Two Main Types of Headers: 

Request Headers ‚Üí Sent from client to server (e.g., browser to API) 

Response Headers ‚Üí Sent from server to client (e.g., API to browser) 

Common HTTP Request Headers 

Content-Type	----->>Tells the server what kind of data is being sent (e.g., JSON, form data, image/jpeg) 

Accept------>>Tells the server what kind of response the client wants (e.g., JSON, XML) 

Authorization	------->>Used for passing tokens or credentials (e.g., JWT, Basic Auth) 

What is "Authorization" header? 

The Authorization header is commonly used to send security credentials, like: 

Bearer tokens (JWT) 

Basic Auth 

API keys 

It grabs the token from the request header and passes it into your method for processing. 

User-Agent------->>Info about the client making the request (e.g., Chrome, Postman) 

 
How the flow works: 

React app sends POST to /api/students with JSON student data. 

Controller receives it and calls studentService.saveStudent(student) 

Service calls studentRepository.save(student) 

Repository saves it to the database using JPA. 

 

Example: 

Controller = Waiter taking your order 

Service = Chef making the pizza 

Repository = Database (Kitchen fridge) storing ingredients 

 

Notes: 

What is Dependency Injection (DI)? 

Stage 1: Dependency Injection is a design pattern that allows Spring to automatically manage the dependencies between different components (like Services, Repositories, Controllers) in your application, in simple terms instead of you manually creating or managing those dependencies, getting from external sources 
 

Stage 2: In your Controller, Service, or Repository, declare dependencies (e.g., another Service or Repository). 

Stage 3: Use @Autowired to tell Spring to inject the dependency 

Picture 
due to loose coupling , makes it easier to update and replace without affecting 
Picture 

This is how application property looks: 
spring.application.name=Springboot-demo-bank-application 

server.port=8902 

 

spring.datasource.url=jdbc:mysql://localhost:3306/springbootbank 

spring.datasource.username=root 

spring.datasource.password=Saru@123 

spring.jpa.hibernate.ddl-auto=update 

spring.jpa.show-sql=true 

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect 

This sets the name of your application 

This sets the port on which your app will run. 

üëâ So your app will run at: http://localhost:8902 

This is the JDBC URL to connect to your MySQL database. 

localhost ‚Üí Your DB is running on your machine 

3306 ‚Üí MySQL‚Äôs default port 

springbootbank ‚Üí The name of your MySQL database (make sure it's created) 

These are your database credentials. 

PicturePrints all SQL queries to the console/logs ‚Äî spring.jpa.show-sql=true 

Spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect 

‚úÖ Tells Hibernate how to translate Java objects into SQL based on your DB 

Why DTO? 

Keep your entity classes clean 

Protect sensitive DB fields from being exposed 

Have more control over your API input/output 

Make validation easier and safer 

Example: 
Step 1: 
@Entity 

public class Student { 

    @Id 

    @GeneratedValue(strategy = GenerationType.IDENTITY) 

    private Long id; 

  

    private String name; 

    private int age; 

  

    // Getters and setters 

} 

Step 2: 
public class StudentDTO { 

    private String name; 

    private int age; 

  

    // Getters and setters 

} 

Step 3:  
@Service 

public class StudentService { 

  

    @Autowired 

    private StudentRepository studentRepository; 

  

    public StudentDTO saveStudent(StudentDTO studentDTO) { 

        Student student = new Student(); 

        student.setName(studentDTO.getName()); 

        student.setAge(studentDTO.getAge()); 

  

        studentRepository.save(student); 

  

        return studentDTO; 

    } 

} 

 

 

 

Jwt:  

When a client sends a request with a JWT token, your app: 

Intercepts the request. 

Looks for the header: 

Authorization: Bearer <JWT_TOKEN> 

 

Parses and validates the token. 

If valid, it authenticates the user and allows the request to go through. 

Very Important flow of JWT token: 

1. Extract the Authorization Header 

final String authorizationHeader = request.getHeader("Authorization"); 
 

‚û°Ô∏è It checks if the client sent a JWT token in the request header like: 

Authorization: Bearer eyJhbGciOiJIUzI1NiJ9... 

2. Split the Header and Extract the Token  
 
if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) { 

    jwt = authorizationHeader.substring(7); // remove "Bearer " 

    username = jwtTokenUtil.extractUsername(jwt); // decode to get username 

} 

It gets the actual token from the header and calls: 

jwtTokenUtil.extractUsername(jwt); 
Which decodes the token and gets the username (like nivedha). 

3. Check if User is Not Already Authenticated  
if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {  

‚û°Ô∏è If the user isn‚Äôt already logged in (no security context), proceed to authenticate 

4. Load User Details from DB (or In-Memory) Gets the full user data: password, roles, authorities, etc. 

UserDetails userDetails = this.jwtUserDetailsService.loadUserByUsername(username); 

5.validate 

if (jwtTokenUtil.validateToken(jwt, userDetails)) { 

Calls: validateToken(token, userDetails) 

Token username matches 

Token is not expired 

6. Set the User as Authenticated  
This sets the authentication inside the Spring Security context, so future filters/controllers know that: 

This user is logged in 

This user has ROLE_USER / ADMIN etc. 

7.Allow Request to proceed 

chain.doFilter(request, response);  

‚û°Ô∏è The filter chain continues. Now the controller is free to handle the request ‚Äî and it knows who the user is (thanks to SecurityContextHolder). 

Small Recap: 
Picture 

JwtTokenUtil (Token Manager) 

This class creates and validates tokens. 

generateToken(userDetails): Creates a JWT token for a user. 

Example: If a user nivedha logs in, the token will look like: 

{ 
  "sub": "nivedha", 
  "role": "[ROLE_USER]", 
  "exp": <10-hours from now> 
} 
 

extractUsername(token): Gets username (subject) from the token. 

extractRole(token): Gets the role from the token. 

validateToken(token, userDetails): Checks if the token matches the user and is not expired. 

 

 
1. Claims are key-value pairs inside a JWT that carry information about the user or session. 

String username = extractClaim(token, Claims::getSubject); 

This would return the "sub" claim (which is usually the username). 

 

How jwt +Login works: 
 

@PostMapping("/login") 

public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequestDto authenticationRequest) throws Exception { 

 

Authentication authentication= authenticationManager.authenticate( 

new UsernamePasswordAuthenticationToken(authenticationRequest.getUsername(), authenticationRequest.getPassword()) 

); 

SecurityContextHolder.getContext().setAuthentication(authentication); 

final UserDetails userDetails = (UserDetails)authentication.getPrincipal(); 

final String token = jwtTokenUtil.generateToken(userDetails); 

System.out.println(userDetails.getAuthorities().toString()); 

return ResponseEntity.ok(new JwtResponseDto(token).getToken()); 

} 


Note  

The authenticationRequest is an object, typically a JwtRequestDto, that holds the user's username and password for authentication. It is passed in the HTTP request body using @RequestBody, which automatically binds the incoming JSON data to the object. This means that when the user sends a login request (for example, with a JSON payload containing their credentials), Spring Boot will automatically convert that JSON into an instance of JwtRequestDto. This process eliminates the need for manual parsing, simplifying the handling of user input. The object is then used to authenticate the user via authenticationManager.authenticate(). If authentication is successful, a JWT token is generated and returned to the user. 

like this From { "name": "Nivedha", "age": 17, "email": "nivedha@email" } To Student student = new Student("Nivedha", 17, "nivedha@email") 

 
 
The authenticationRequest is typically an object that holds the credentials or authentication data provided by the user to authenticate and gain access to a system 
  like: 
	authenticationRequest.getUsername() 
	authenticationRequest.getPassword() 

authentication.getPrincipal() ‚Üí user details (username, password, roles, etc.) 

authentication.getAuthorities() ‚Üí only the roles/permissions 

 

You're immediately calling .getToken() on that object, which just returns the token string. 

new JwtResponseDto(token).getToken() 

just returns a plain string like: 

"eyJhbGciOiJIUzI1NiIsInR..."  

If you want to return the token as a JSON object like: 

Then you should return the whole object, not just .getToken(): 

return ResponseEntity.ok(new JwtResponseDto(token));  

{ 

  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." 

} 

 
Need to know: 
You log into an app. Now that you're authenticated, the app needs to remember who you are during the rest of your session. 

That "memory" of your authentication info is stored in something called the Security Context. 

üîê What is Security Context? 

It‚Äôs a container provided by Spring Security to store: 

The current user‚Äôs authentication information 

User details (username, roles, etc.) 

Whether the user is logged in 

It's stored in a thread-local variable, so each request gets its own isolated context. 

 

 

 

 

How registration works: 
 

public int registerUser(User user, String password) { 

user.setPassword(passwordEncoder.encode(password)); 

user = userRepository.save(user); 

 

if (user != null) { 

createBankAccount(user); 

return user.getUserId(); 

} 

return -1; 

} 

 

Frontend sends a JSON POST request with user details. 

@RequestBody maps that to a User object. 

@PostMapping("/register") 

public ResponseEntity<?> registerUser(@RequestBody User user) throws Exception { 

// The <?> is a generic wildcard in Java ‚Äî it means: 

"This ResponseEntity can return a response of any type ‚Äî I‚Äôm not restricting it." 

 

int userId = userDetailsService.registerUser(user, user.getPassword()); 

 

if (userId != -1) { 

String accountNumber = user.getBankAccounts().iterator().next().getAccountNumber(); 

return ResponseEntity.ok("User registered successfully with accountNumber: " + accountNumber); 

} else { 

return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) 

.body("User registration failed."); 

} 

} 

 

 
How this works is important : 

@RequestBody User user: 
Spring Boot automatically takes the incoming JSON request and converts it into a User object 

For example, this JSON: 

{ 
  "username": "nivedha", 
  "password": "abc123" 
} 
 

‚Ä¶gets mapped to: 

User user = new User(); 
user.setUsername("nivedha"); 
user.setPassword("abc123"); 

 
 
private void createBankAccount(User user) { 

BankAccount bankAccount = new BankAccount(); 

bankAccount.setUser(user); 

bankAccount.setAccountNumber(generateAccountNumber()); 

bankAccount.setPin(secureRandom.nextInt(10000)); 

bankAccount.setMfaPin(1111 + user.getUserId()); 

bankAccount.setBalance(BigDecimal.valueOf(500)); 

bankAccount.setInitialBalance(BigDecimal.valueOf(500)); 

bankAccount = bankAccountRepository.save(bankAccount); 

 

if (user.getBankAccounts() == null) { 

user.setBankAccounts(new HashSet<>());  // o HashSet ensures: 

A bank account is added only once to the user's collection 

The collection doesn't allow duplicate account objects 

 

} 

user.getBankAccounts().add(bankAccount); 

String email = user.getUsername() + "@oksbi"; 

user.setEmail(email); 

user.setStatus("ACTIVE"); 

userRepository.save(user);  

} 

 

private String generateAccountNumber() { 

return "ACC" + secureRandom.nextInt(10000000); 

} 

How we upload and fetch profile picture: 
"The picture which I'm uploading using the key picture will be stored as a MultipartFile, right?" 

‚úÖ Correct! Spring reads the uploaded file using the key "picture" and wraps it in a MultipartFile object.  And Spring captures it as a MultipartFile. 

@PostMapping("/uploadPicture/{username}") 

public ResponseEntity<String> uploadPicture(@PathVariable String username, @RequestParam("picture") MultipartFile pictureFile) { 

try { 

User user = userRepository.findByUsername(username); 

if (user == null) { 

throw new RuntimeException("User not found"); 

} 

user.setPicture(pictureFile.getBytes()); 

userRepository.save(user); 

return ResponseEntity.ok("Picture uploaded successfully"); 

} catch (IOException e) { 

return ResponseEntity.status(500).body("Failed to upload picture"); 

} 

} 


Expect a file named picture in the request and treat it as a file 

Since databases can‚Äôt directly store files, we convert the image into raw data (bytes) and save that into the database. And save it into the picture field of the User object. 

store this image directly in the database as a byte array (blob) 

Get the image : 
produces = ... = tells what type of data you're sending back. 

MediaType.IMAGE_JPEG_VALUE = you're sending back a JPEG image. 

@GetMapping(value = "/getPicture/{username}", produces = MediaType.IMAGE_JPEG_VALUE) 

public ResponseEntity<byte[]> getPicture(@PathVariable String username) { 

User user = userRepository.findByUsername(username); 

if (user == null) { 

throw new RuntimeException("User not found"); 

} 

byte[] picture = user.getPicture(); 

return ResponseEntity.ok().contentType(MediaType.IMAGE_JPEG).body(picture); 

} 

.body(picture) = sends the image data (as bytes) in the response 


How can we fetch the username ? 

String username = jwtTokenUtil.extractUsername(jwtToken); 

You receive the JWT token (usually from the Authorization header), and you want to extract the username stored inside the token. 

üî∏ Why: 

This is secure and preferred in authenticated APIs, because: 

Username is verified from the signed token. 

You‚Äôre not relying on the client to send username manually. 

@GetMapping("/getUser/{username}")  

public User getUser(@PathVariable String username) {  

return userRepository.findByUsername(username);  

}  

üî∏ Used when:  

The client sends the username explicitly in the URL.  

üî∏ Why:  

This is easier for testing or open endpoints, but less secure because:  

Anyone can send any username in the URL.  

It‚Äôs not verified unless you manually cross-check it with the token user. 

How springboot magically creates simple queries internally ? 


@PostConstruct 


The @PostConstruct annotation is used in Spring to indicate that the annotated method should be executed after the bean's properties have been set and the bean has been initialized. In other words, it runs once the Spring container has fully initialized the bean and all its dependencies have been injected. 
 
in other words 
Now, when Spring creates a bean (for example, a service), it also injects any dependencies that the bean might need (like other services or repositories). This injection process happens automatically, and once all dependencies are injected, Spring considers the bean ready for use. 

The @PostConstruct annotation marks a method that should run after Spring has finished creating the bean and injecting its dependencies. This means that the method annotated with @PostConstruct will execute once everything is set up and the bean is fully initialized. 

 
the method init() is annotated with @PostConstruct, which means it will automatically execute after the bean is created and all the dependencies are injected. Inside the init() method, you have a call to createAdmin(), which likely creates an admin user in your system, ensuring that the admin user is created as soon as the application starts. 

How to validate account number and pin are right or wrong ? 
private boolean isAccountNumberValid(String accountNumber) { 
 return accountNumber != null && !accountNumber.isEmpty(); 

} 
 
private boolean isAccountNumberValid(String accountNumber) { 

  

 return accountNumber != null && !accountNumber.isEmpty(); 

} 

 

private boolean isPinValid(String username, String accountNumber, int pin) { 

 User user = userDetailsService.findByUsername(username);  

 if (user != null) { 

 for (BankAccount bankAccount : user.getBankAccounts()) {  

 if (bankAccount.getAccountNumber().equals(String.valueOf(accountNumber)) && bankAccount.getPin() == pin) { 

 //obviously the user going to have one account inorder to cross check 

 	//i have set a validation using if clause that bank account fetched account number and pin 

 // and the dto's actual account number and pin matches or not 

 	return true;  

 	 

 } 

 } 

 } 

 return false;  

} 

 

 

 

Atm deposit code 
 

package com.bank.controller; 

import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.Optional; 

import com.bank.dto.DepositRequestDto; import com.bank.jwt.JwtTokenUtil; import com.bank.model.BankAccount; import com.bank.model.CardBlockStatus; import com.bank.model.User; import com.bank.service.JwtUserDetailsService; 

@RestController @RequestMapping("/atm/process") public class DepositController_Atm { 

   @Autowired 
    private AuthenticationManager authenticationManager; 
 
    @Autowired 
    private JwtTokenUtil jwtTokenUtil; 
 
    @Autowired 
    private JwtUserDetailsService userDetailsService; 
 
 
@PostMapping("/deposit") 
public ResponseEntity<String> atmDeposit(@RequestBody DepositRequestDto depositRequest, 
                                            @RequestHeader("Authorization") String token) { 
   
    String jwtToken = token.substring(7); 
 
    String username = jwtTokenUtil.extractUsername(jwtToken); 
     
    System.out.println("Username from token: " + username); 
 
    User user = userDetailsService.findByUsername(username); 
    if (user == null) { 
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("User not found."); 
    } 
    if (!isAccountNumberValid(depositRequest.getAccountNumber())) { 
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Invalid account number."); 
    } 
 
    String accountNumber = depositRequest.getAccountNumber(); 
    if (!isPinValid(username, accountNumber, depositRequest.getPin())) { 
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid account number or PIN."); 
    } 
     
    Optional<CardBlockStatus> cardBlockStatusOpt = userDetailsService.getCardBlockStatusByAccountNumber(depositRequest.getAccountNumber()); 
    if (cardBlockStatusOpt.isPresent() && "approved".equalsIgnoreCase(cardBlockStatusOpt.get().getStatus())) { 
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Your card is blocked. You cannot make deposits."); 
    } 
 
    boolean success = userDetailsService.atmDeposit(user.getUserId(), depositRequest.getAmount()); 
    if (success) { 
        return ResponseEntity.ok("Atm Deposit successful!"); 
    } else { 
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Deposit failed."); 
    } 
} 
private boolean isAccountNumberValid(String accountNumber) { 
     
    return accountNumber != null && !accountNumber.isEmpty(); 
} 
 
private boolean isPinValid(String username, String accountNumber, int pin) { 
    User user = userDetailsService.findByUsername(username);  
    if (user != null) { 
        for (BankAccount bankAccount : user.getBankAccounts()) {  
            if (bankAccount.getAccountNumber().equals(String.valueOf(accountNumber)) && bankAccount.getPin() == pin) { 
                //obviously the user going to have one account inorder to cross check 
                //i have set a validation using if clause that bank account fetched account number and pin 
            // and the dto's actual account number and pin matches or not 
                return true;  
                 
            } 
        } 
    } 
    return false;  
} 
  

} 

 
public Optional<CardBlockStatus> getCardBlockStatusByAccountNumber(String accountNumber) { 

Optional<BankAccount> bankAccountOpt = bankAccountRepository.findByAccountNumber(accountNumber); //account number 

if (bankAccountOpt.isPresent()) { //yes 

return cardBlockStatusRepository.findByBankAccount(bankAccountOpt.get()); 

} 

return Optional.empty(); 

} 

public boolean atmDeposit(int userId, BigDecimal amount) { 

BankAccount bankAccount = bankAccountRepository.findByUser_UserId(userId) 

.orElse(null); 

 

if (bankAccount == null) { 

return false; 

} 

BigDecimal newBalance = bankAccount.getBalance().add(amount); 

bankAccount.setBalance(newBalance); 

bankAccountRepository.save(bankAccount);  

Deposit deposit = new Deposit(); 

deposit.setBankAccount(bankAccount); 

deposit.setAmount(amount); 

deposit.setDepositDate(LocalDate.now()); 

depositRepository.save(deposit); 

 

TransactionHistory depositTransaction = new TransactionHistory(); 

depositTransaction.setBankAccount(bankAccount); 

depositTransaction.setAmount(amount); 

depositTransaction.setDate(LocalDate.now()); 

depositTransaction.setDescription("Deposit transaction"); 

depositTransaction.setType("Atm Deposit"); 

transactionHistoryRepository.save(depositTransaction); 

 

return 
public boolean atmDeposit(int userId, BigDecimal amount) { 

BankAccount bankAccount = bankAccountRepository.findByUser_UserId(userId) 

.orElse(null); 

 

if (bankAccount == null) { 

return false; 

} 

BigDecimal newBalance = bankAccount.getBalance().add(amount); 

bankAccount.setBalance(newBalance); 

bankAccountRepository.save(bankAccount);  

Deposit deposit = new Deposit(); 

deposit.setBankAccount(bankAccount); 

deposit.setAmount(amount); 

deposit.setDepositDate(LocalDate.now()); 

depositRepository.save(deposit); 

 

TransactionHistory depositTransaction = new TransactionHistory(); 

depositTransaction.setBankAccount(bankAccount); 

depositTransaction.setAmount(amount); 

depositTransaction.setDate(LocalDate.now()); 

depositTransaction.setDescription("Deposit transaction"); 

depositTransaction.setType("Atm Deposit"); 

transactionHistoryRepository.save(depositTransaction); 

 

return true; 

} 

 

 

@Profile 
 
 

Absolutely! Here's a simple explanation of how Spring Boot manages multiple environments using @Profile 

In real projects, you often need different configurations for: 

üë®‚Äçüíª Development (local DB, debug logs) 

üß™ Testing (test DB, mock services) 

üöÄ Production (real DB, security, minimal logging) 

You can tag a bean or config class to only be active in a specific environment. 

@Configuration  

@Profile("dev")  

public class DevConfig {  

@Bean  

public String exampleBean() {  

return "I‚Äôm a DEV bean!";  

}  

} 

 


spring.profiles.active 

spring.profiles.active 

Tell Spring which profile to use by setting this in: 

application.properties 

spring.profiles.active=dev 

or in terminal 

-Dspring.profiles.active=prod 

 

You can create separate config files for each profile: 

application-dev.properties 

application-test.properties 

application-prod.properties 

 

Spring Boot will automatically pick the right one based on spring.profiles.active 

Great question! Let me explain how your frontend (Angular) and backend (Spring Boot) are connected step by step, in very simple terms. 

 

üîó How Frontend and Backend Connect: 

üìç Step 1: Backend listens on a port 

# In application.properties 
server.port=8902 
  

This means your Spring Boot backend is running at: 

 üëâ http://localhost:8902 

 

üìç Step 2: Backend exposes an API endpoint 

@PostMapping("/register") 
public ResponseEntity<?> registerUser(@RequestBody User user) { 
    // logic to register user 
} 
  

This is available at: 

 üëâ http://localhost:8902/register 

(Assuming the controller is mapped like @RequestMapping("/auth"), then full path is /auth/register) 

 

üìç Step 3: Frontend calls that endpoint using HttpClient 

private apiUrl = 'http://localhost:8902/auth/register'; 
  

This URL is where Angular sends the data (user object) using a POST request. 

So, when this runs: 

this.http.post(this.apiUrl, user) 
  

Angular is literally saying: 

‚ÄúHey backend at localhost:8902, I‚Äôm sending a user object to /auth/register. Please process it!‚Äù 

 

üß© How it works together: 

Component 

Responsibility 

Angular (frontend) 

Sends data via HTTP request (POST) 

Spring Boot (backend) 

Listens on port 8902 & handles request 

API URL 

Acts as a bridge between both sides 

 

üß™ Example Flow 

User fills the register form in Angular 

Clicks "Register" ‚Üí triggers this.http.post(...) 

Angular sends the JSON payload to http://localhost:8902/auth/register 

Spring Boot receives it, processes it, and responds (like: "Account created!") 

Angular receives the response and shows alert/logs message 

Note:
@Autowired is used for Dependency Injection (DI) in Spring. 

It tells Spring: 
"Hey Spring, please automatically inject (or wire) this dependency for me! 

Because in big applications, we don‚Äôt want to manually create objects using new. Spring handles object creation and wiring automatically to promote loose coupling and easy testing. 

 

Location 

Example 

Field (most common) 

‚úÖ 

Constructor 

‚úÖ (Recommended for final fields) 

Cleaner, better for unit testing (because you can pass mock objects in the constructor). 

Setter method 

‚úÖ Used when the dependency is optional or can be changed after creation. 
